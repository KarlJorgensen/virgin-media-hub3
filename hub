#!/usr/bin/python3
"""General command-line interface to the Virgin Media Hub3

"""
import argparse
import json
import os

import snmp
import utils
import virginmedia

SUBCOMMANDS = []

def subcommand(func):
    """A function decorator for subcommands"""
    SUBCOMMANDS.append(func)
    return func

# pylint: disable=R0903
class Args:
    """A function decorator that adds arguments to a subcommand.

    It should be passed an array of (args, kwargs) - these will be
    used (eventually) call ArgumentParser.add_argument()

    """
    def __init__(self, args):
        self._args = args

    def __call__(self, func):
        func.args = self._args
        return func

def nologin(func):
    """A function decorator that flags the subcommand as not needing login"""
    func.needs_login = False
    return func

def nohub(func):
    """A function decorator that flags the subcommand as not needing a hub to talk to"""
    func.needs_hub = False
    return func

def dump_properties(hub, props):
    """Print the listed properties on stdout, nicely formatted"""
    for prop in props:
        print(prop, ":", getattr(hub, prop))

@subcommand
def info(hub, _args):
    """Show General information about the hub."""
    dump_properties(hub,
                    [
                        "modelname",
                        "family",
                        "hardware_version",
                        "serial_number",
                        "bootcode_version",
                        "firmware_version",
                        "name",
                        "current_time",
                        "first_install_wizard_completed",
                        "wan_ip_prov_mode",
                        "wan_current_ipaddr_ipv4",
                        "wan_current_ipaddr_ipv6",
                        "dns_servers",
                        "cmDoc30SetupPacketCableRegion"
                    ])

@subcommand
@Args([
    ("outfile", dict(help="File name to write backup to - defaults to 'router.data'",
                     type=argparse.FileType(mode='wb'),
                     default='router.data',
                     nargs='?'))])
def backup(hub, args):
    """Make a backup of the router configuration.

    The resulting file is a binary hub-proprietary file, essentially
    only useful for restoring into the hub - the internal structure is
    not (yet) known.

    """
    args.outfile.write(hub.backup())
    args.outfile.close()

@subcommand
def wan_status(hub, _args):
    """Show Wide Area Network settings."""
    dump_properties(hub,
                    [
                        "wan_if_macaddr",
                        "wan_mtu_size",

                        "wan_current_ipaddr_ipv4",
                        "wan_current_netmask",
                        "wan_current_gw_ipv4",
                        "wan_dhcp_duration_ipv4",

                        "wan_current_ipaddr_ipv6",
                        "wan_dhcp_duration_ipv6",
                        "wan_current_gw_ipv6",

                        "wan_dhcp_server_ip",

                        "wan_conn_hostname",
                        "wan_conn_domainname",
                        "dns_servers"
                        ])

@subcommand
def wan_iplist(hub, _args):
    """Prints the current external IP addresses of the hub."""
    print(hub.wan_current_table.format_by_row())

@subcommand
def lan_networks(hub, _args):
    """Information about the local LAN networks.

    The router can actually handle more than one network.  A single
    network can span multiple interfaces.

    """
    print(hub.lan_networks.format_by_row())

@subcommand
def wifi_status(hub, _args):
    """Show WIFI Status."""
    dump_properties(hub,
                    [
                        "wifi_24ghz_essid",
                        "wifi_24ghz_password",
                        "wifi_5ghz_essid",
                        "wifi_5ghz_password",
                        "lan_gateway",
                        "lan_subnetmask",
                        "lan_dhcp_enabled",
                        "lan_dhcpv4_range_start",
                        "lan_dhcpv4_range_end",
                        "lan_dhcpv4_leasetime",
                    ])

@subcommand
@Args([
    ("--long", dict(help="Show the 'long' format of the table",
                    action="store_true"))
    ])
def wifi_clients(hub, args):
    """List WIFI clients."""
    clients = hub.wifi_clients

    print("There are {0:d} distinct WIFI clients (across {1:d} IP addresses):"
          .format(len(list(utils.unique_everseen([x.macaddr
                                                  for x in clients.values()]))),
                  len(list(utils.unique_everseen([x.ipaddr
                                                  for x in clients.values()])))))
    if args.long:
        print(clients.format_by_row())
    else:
        clients = utils.select_columns(clients,
                                       ["macaddr",
                                        "hostname",
                                        "ipaddr",
                                        "tx_packets",
                                        "tx_fail",
                                        "rx_unicast_pkts",
                                        "last_rx_rate",
                                        "rssi"])
        best_rssi = max([row['rssi'] for row in clients.values()])
        worst_rssi = min([row['rssi'] for row in clients.values()])
        scale = 10

        def rss_scale(rssi):
            val = int(scale * (rssi - worst_rssi) / (best_rssi - worst_rssi) + 0.5)
            return "*" * val

        for row in clients.values():
            row['signal'] = rss_scale(row['rssi'])

        clients = utils.sort_table(clients,
                                   key=lambda row: (row['macaddr'],
                                                    row['ipaddr']))
        print(utils.format_table(clients))

@subcommand
@Args([
    ("--long", dict(help="Show the 'long' format of the table",
                    action="store_true"))
    ])
def portforward_list(hub, args):
    """List current port forwardings."""

    pflist = hub.portforwards
    if args.long:
        print(utils.format_by_row(pflist))
    else:
        pflist = utils.sort_table(pflist,
                                  key=lambda x: (x['ext_port_start']))
        def portsummary(start, end):
            if start == end:
                return start
            return "{0}-{1}".format(start, end)

        pflist = utils.select_columns(pflist,
                                      ["rowstatus",
                                       "proto",
                                       "ext_port_start",
                                       "ext_port_end",
                                       "local_addr",
                                       "local_port_start",
                                       "local_port_end"])
        pflist = utils.filter_table(pflist,
                                    rowstatus=snmp.RowStatus.ACTIVE)
        for row in pflist.values():
            row['ext_ports'] = portsummary(row['ext_port_start'], row['ext_port_end'])
            row['local_ports'] = portsummary(row['local_port_start'], row['local_port_end'])

        pflist = utils.select_columns(pflist,
                                      ["proto",
                                       "ext_ports",
                                       "local_addr",
                                       "local_ports"])
        print(utils.format_table(pflist))

@subcommand
@Args([
    ("protocol", {"help":"Protocol to forward",
                  "choices": [p.name for p in snmp.IPProtocol]}),
    ("external_port", {"type": int,
                       "help": "The external port number to map"}),
    ("internal_ip", {"help": "Internal IP address to map it to"}),
    ("internal_port", {"type": int,
                       "help": "The internal port number to map it to"})
])
def portforward_add(hub, args):
    """Add a port forwarding entry.

    This directs the hub to forward incoming traffic (arriving at the
    external interface) on that port to some port internally.

    """
    hub.portforward_add(
        proto=snmp.IPProtocol[args.protocol],
        ext_port_start=args.external_port,
        local_port_start=args.internal_port,
        local_addr=args.internal_ip)
    hub.apply_settings()

@subcommand
@Args([
    ("entry", {"help": "Row number of entry to remove"})
    ])
def portforward_del(hub, args):
    """Remove a port forwarding entry.
    """
    pflist = hub.portforwards
    if args.entry not in pflist:
        print(utils.format_by_row(pflist))
        raise SystemExit("Port forward %s was not found" % args.entry)

    del hub.portforwards[args.entry]
    hub.apply_settings()
    print("Port forward entry %s deleted" % args.entry)

@subcommand
def ether_ports(hub, _args):
    """List ethernet ports on the hub."""
    print(utils.format_table(hub.etherports))

@subcommand
def wifi_networks(hub, _args):
    """List WIFI networks."""
    print(utils.format_by_row(hub.bsstable))

@subcommand
def device_list(hub, _args):
    """List devices connected to the hub."""
    for dev in hub.device_list():
        print(dev)

@subcommand
def lan_clients(hub, _args):
    """List known LAN clients."""
    clients = utils.sort_table(hub.lan_clients, key=lambda x: x.mac_address)
    print("There are %d known clients:" % len(clients))
    print(utils.format_table(clients))
    print("Note: This list includes both wired and wireless clients")

@subcommand
@Args([
    ("--quiet", dict(action="store_true"))])
def reboot(hub, args):
    """Instructs the hub to reboot.

    The hub will start to reboot - it will take a few minutes before
    it is fully back.

    """
    hub.reboot()
    if not args.quiet:
        print("{0} is now rebooting. It will be down for a few minutes".format(hub))

@subcommand
@nohub
def property_list(_args):
    """Get a list of the known property names.

    Not all properties will be settable.

    """
    for prop in sorted(virginmedia.HUB_PROPERTIES):
        print(prop)

@subcommand
@Args([
    ("property", {"nargs": "+",
                  "help": "The property to retrieve",
                  "choices": virginmedia.HUB_PROPERTIES})
])
def property_get(hub, args):
    """Get one or more properties."""
    for prop in args.property:
        print(getattr(hub, prop))

@subcommand
@Args([
    ("--skip-get", {"help": "Do not try to retrieve the property first",
                    "action": "store_true"}),
    ("property", {"help": "The name of the property to set",
                  "choices": virginmedia.HUB_PROPERTIES}),
    ("value", {"help": "Value to set the property to"})])
def property_set(hub, args):
    """Set a specific property.

    Note that not all properties are settable.

    """
    if not args.skip_get:
        oldvalue = getattr(hub, args.property)

        if oldvalue == args.value:
            print("Property", args.property, "is already set to", args.value)
            return

    try:
        setattr(hub, args.property, args.value)
    except AttributeError:
        raise SystemExit("Property {0} is not settable".format(args.property))

    if args.skip_get:
        print("Set", args.property, "to", args.value)
    else:
        print("Changed", args.property, "from", oldvalue, "to", args.value)

@subcommand
@Args([
    ("oid", {"help": "OID of the SNMP property to retrieve. " \
             "This should be given as a dot-separated number string, " \
             "e.g. '1.3.6.1.4.1.4115.1.20.1.1.5.10.0'"})])
def snmp_get(hub, args):
    """Retrieve an SNMP property from the hub.

    This is mostly useful for developers. The output of this command
    may vary between versions.

    """
    args.oid = args.oid.strip('.')
    print("{o} = {v}".format(o=args.oid, v=hub.snmp_get(args.oid)))

@subcommand
@Args([
    ("oid", {"help": "OID of the SNMP property to retrieve. " \
             "This should be given as a dot-separated number string, " \
             "e.g. '1.3.6.1.4.1.4115.1.20.1.1.5.10.0'"}),
    ("value", {"help": "The value to set it to. Is will be the raw string as sent to the hub"}),
    ("type", {"help": "SNMP Data type (I think)",
              "choices": snmp.DataType.__members__.keys(),
              "nargs": "?"})
])
def snmp_set(hub, args):
    """Set an SNMP attribute.

    This is mostly useful for developers, as it requires knowledge of
    SNMP and the relevant MIBs.

    """
    args.oid = args.oid.strip('.')
    if args.type is not None:
        args.type = snmp.DataType[args.type]

    res = hub.snmp_set(args.oid, value=args.value, datatype=args.type)
    print("Result:", res)

@subcommand
@Args([
    ("--byrow", {"help": "Arrange output on a row-by-row basis",
                 "action": "store_true"}),
    ("oid", {"help": "OID of the SNMP property walk down from. " \
             "This should be given as a dot-separated number string, " \
             "e.g. '1.3.6.1.4.1.4115.1.20.1.1.5.10.0'"})])
def snmp_walk(hub, args):
    """Do an SNMP walk on the hub.

    This is mostly useful for developers. The output of this command
    may vary between versions.

    This will produce a json-representation of the result
    """
    args.oid = args.oid.strip('.')
    walk_result = hub.snmp_walk(args.oid)
    if args.byrow:
        walk_result = snmp.parse_table(args.oid, walk_result)

    print(json.dumps(walk_result, sort_keys=True, indent=2))

def main():
    """Main function. Obviously!"""

    parser = argparse.ArgumentParser()
    parser.add_argument("--host", "-H",
                        help="IP Address/dns name of the hub. "
                        "Uses the HUB environment variable as a default value"
                        "- and 192.168.0.1 if that is not set",
                        default=os.environ.get("HUB", "192.168.0.1"))
    parser.add_argument("--username", "-u",
                        help="User name to login as. "
                        "Uses the HUB_USER environment variable as a default value"
                        " - and 'admin' if that is not set",
                        default=os.environ.get("HUB_USER", "admin"))
    parser.add_argument("--password", "-p",
                        help="Password to authenticate on the hub. "
                        "Uses the HUB_PASSWORD environment variable if not specified. "
                        "If not password is given, no login will be attempted",
                        default=os.environ.get("HUB_PASSWORD"))
    parser.add_argument("--timeout",
                        help="Timeout for HTTP requests to the router in seconds. "
                        "Defaults to 10 seconds.",
                        type=int)
    subparsers = parser.add_subparsers(description="The subcommands specify what should be done")

    for cmd in sorted(SUBCOMMANDS, key=lambda x: x.__name__):
        cmd_parser = subparsers.add_parser(cmd.__name__.lower().replace('_', '-'),
                                           help=cmd.__doc__)

        if hasattr(cmd, 'args'):
            for arg in cmd.args:
                cmd_parser.add_argument(arg[0], **arg[1])
        cmd_parser.set_defaults(func=cmd)

    args = parser.parse_args()
    if not hasattr(args, "func"):
        parser.print_usage()
        raise SystemExit()

    try:
        needs_login = args.func.needs_login
    except AttributeError:
        needs_login = True

    try:
        needs_hub = args.func.needs_hub
    except AttributeError:
        needs_hub = True

    if needs_hub:
        with virginmedia.Hub() as hub:
            if args.timeout:
                hub.http_timeout = args.timeout
            if needs_login and args.password:
                hub.login(username=args.username,
                          password=args.password)
            args.func(hub, args)
    else:
        args.func(args)

if __name__ == '__main__':
    main()
